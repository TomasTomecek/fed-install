#!/usr/bin/python3

from __future__ import print_function, absolute_import, unicode_literals

import os
import sys
import argparse
import subprocess
import logging
import tempfile
import string
import random
import shutil


UPDATES_TESTING_REPO_NAME = "updates-testing"
UPDATES_REPO_NAME = "updates"
FEDORA_REPO_NAME = "fedora"
# <tag>-build
KOJI_TARGET_REPO = "https://kojipkgs.fedoraproject.org/repos/{target}/latest/{basearch}/"


def set_logging(name="fed-install", level=logging.DEBUG):
    # create logger
    logger = logging.getLogger(name)
    logger.handlers = []
    logger.setLevel(level)

    # create console handler and set level to debug
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)

    # create formatter
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    # add formatter to ch
    ch.setFormatter(formatter)

    # add ch to logger
    logger.addHandler(ch)


# TODO: set logging in cli
set_logging(level=logging.DEBUG)  # override this however you want
logger = logging.getLogger("fed-install")


def create_dnf_command(repos, packages, dnf_command, enable_predefined_repos, yes,
                         enable_repos=None, releasever=None):
    """
    repos = [
        {
            "name": ...,
            "url": ...,
        }
    ]
    """
    # Igor, if you read this, I'm pretty sure you facepalm hard
    # Yes, I am lazy to learn and use dnf API
    d = ['dnf']
    if yes:
        d += ['-y', ]
    if not enable_predefined_repos:
        d += ['--disablerepo=*', ]
    if enable_repos:
        for repo in enable_repos:
            d += ["--enablerepo", repo]
    if releasever:
        d += ['--releasever', releasever]
    for repo in repos:
        d += [
            '--repofrompath', '{name},{url}'.format(**repo),
            '--enablerepo', '{name}'.format(**repo),
        ]
    d += ["--disableexcludes", "all"]
    d += ["--refresh", "--nogpgcheck", dnf_command] + packages
    logger.debug(" ".join(d))
    return d


def install_from_koji_tag(koji_tag, packages, arch, dnf_command, enable_predefined_repos, yes):
    repo = KOJI_TARGET_REPO.format(target=koji_tag, basearch=arch)
    repos = [
        {
            "name": koji_tag,
            "url": repo,
        }
    ]
    cmd = create_dnf_command(repos, packages, dnf_command, enable_predefined_repos, yes)
    subprocess.check_call(cmd)


def install_koji_build(build_spec, packages, arch, dnf_command, enable_predefined_repos, yes,
                       preserve_downloaded):
    """
    download a build from koji, create repo from it and install selected packages
    """
    repos = []
    tmpdir = tempfile.mkdtemp()
    cwd = os.getcwd()
    try:
        os.chdir(tmpdir)
        subprocess.check_call(
            ["koji", "download-build", "--arch=noarch", "--arch=%s" % arch, build_spec])
        subprocess.check_call(["createrepo_c", "."])

        random_name = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))

        repo_path = "file://%s" % tmpdir
        repos.append(render_repo(repo_path, random_name))

        cmd = create_dnf_command(repos, packages, dnf_command, enable_predefined_repos, yes)
        # TODO: clean metadata
        subprocess.check_call(cmd)
    finally:
        os.chdir(cwd)
        if not preserve_downloaded:
            shutil.rmtree(tmpdir)


def install_from_stable(release, packages, dnf_command, enable_predefined_repos, yes,
                          enable_updates_testing):
    repos_to_enable = [FEDORA_REPO_NAME, UPDATES_REPO_NAME]
    if enable_updates_testing:
        repos_to_enable += [UPDATES_TESTING_REPO_NAME]
    cmd = create_dnf_command([], packages, dnf_command, enable_predefined_repos,
                             yes, releasever=release, enable_repos=repos_to_enable)
    subprocess.check_call(cmd)


def render_repo(repo_template, name, **kwargs):
    repo = repo_template.format(**kwargs)
    repo_dict = {
        "name": name,
        "url": repo,
    }
    logger.debug(repo_dict)
    return repo_dict


class Application:
    def __init__(self, args):
        self.args = args

    def run(self):
        if self.args.command_name == "koji-build":
            install_koji_build(self.args.BUILD_SPEC, self.args.PACKAGE, self.args.arch,
                               self.args.dnf_command, self.args.enable_predefined_repos,
                               self.args.yes, self.args.preserve_downloaded)
        elif self.args.command_name == 'fedora-release':
            install_from_stable(self.args.FEDORA_RELEASE, self.args.PACKAGE,
                                self.args.dnf_command, self.args.enable_predefined_repos,
                                self.args.yes, self.args.enable_updates_testing)
        elif self.args.command_name == 'koji-tag':
            install_from_koji_tag(self.args.KOJI_TAG, self.args.PACKAGE, self.args.arch,
                                self.args.dnf_command, self.args.enable_predefined_repos,
                                self.args.yes)
        else:
            raise RuntimeError("no such command: %s" % (self.args.command_name, ))


def main():
    parser = argparse.ArgumentParser(
        description="Install packages from stable Fedora releases or from koji."
    )
    exclusive_group = parser.add_mutually_exclusive_group()
    exclusive_group.add_argument("-v", "--verbose", action="store_true", default=None)
    exclusive_group.add_argument("-q", "--quiet", action="store_true")

    parser.add_argument("-y", "--yes", help="YES!", action="store_true")
    parser.add_argument("--dnf-command", default="install",
                        help="dnf command used, such as install, update, downgrade...")
    parser.add_argument("--enable-predefined-repos", action="store_true",
                        help="by default, pass --disablerepo='*' to dnf;"
                             " this argument disables that behavior",
                        default=False)

    subparsers = parser.add_subparsers(help='commands', dest="command_name")

    # FIXME: name the command better
    fed_rel_subp = subparsers.add_parser("fedora-release",
                                         help='install packages from selected Fedora release')
    fed_rel_subp.add_argument("FEDORA_RELEASE",
                              help="For example, 26")
    fed_rel_subp.add_argument("PACKAGE", help="package to install", nargs="+")
    fed_rel_subp.add_argument("--enable-updates-testing", action="store_true",
                              help="also enable 'updates-testing' repo",
                              default=False)

    koji_subp = subparsers.add_parser("koji-tag", help='install packages from a koji tag')
    koji_subp.add_argument("--arch", default="x86_64",
                           help="architecture of binary packages to select")
    koji_subp.add_argument("KOJI_TAG", help="name of koji tag, see `koji list-tags`")
    koji_subp.add_argument("PACKAGE", help="package to install", nargs="+")

    koji_build_subp = subparsers.add_parser("koji-build",
                                            help='install packages from a koji build')
    koji_build_subp.add_argument("--arch", default="x86_64",
                                 help="architecture of packages to download in addition to noarch")
    koji_build_subp.add_argument("--preserve-downloaded", action="store_true", default=False,
                                 help="preserve downloaded packages (by default they are removed)")
    koji_build_subp.add_argument("BUILD_SPEC",
                                 help="<n-v-r | build_id | package>, see `koji download-build -h`")
    koji_build_subp.add_argument("PACKAGE", help="package to install", nargs="+")

    args = parser.parse_args()

    if not args.command_name:
        parser.print_help()
        return -2

    a = Application(args)

    try:
        a.run()
        # parser.print_help()
    except KeyboardInterrupt:
        print("Quitting on user request.")
        return -1
    except Exception as ex:  # pylint: disable=broad-except
        if args.verbose:
            raise
        else:
            logger.error("Exception caught: %s", repr(ex))
            return -1
    return 0


if __name__ == "__main__":
    sys.exit(main())
